---
title: "LPIC101あずき本の1章1節を解説してみた"
date: 2022-12-11T14:17:47+09:00
draft: true
share_img: img/share_img.png
categories: 技術解説
description:
---
<br>

この記事は[TechCommit Advent Calendar 2022](https://adventar.org/calendars/7673) 14日目の記事です。
<br>
<br>

昨年はこのブログではなくQiitaの方で[無線LANのセキュリティ](https://qiita.com/Amybunny/items/f6626b19b5418d1d4f86)について図解したのでそちらも見てみてください☆
<br>
<br>
ところでみなさん、あずき本ってなんであんなに分かりにくい上に高いんですかね。  
AWSなんて安くて分かりやすい本がたくさん出ているのに~~殿様商売しやがって。~~  
この本で理解できる人はこの本の対象読者じゃないと思う。
<br>
<br>

LPICを受ける人はまず[1週間でLPICの基礎が学べる本](https://amzn.asia/d/gLg3Gxc)みたいなのを読んでからあずき本に進むと思うんですけど、前者から後者は一気にハードルがあがる（というかあずき本の記述が不親切すぎて多分理解できない）んですよね。
<br>
<br>
そもそもいきなり1章でシステムアーキテクチャを持ってこられると面食らうんです。
<br>
<br>
1ページからなんとか読み進めても、1.1.3で「Linuxは、ハードウェアのアクセスを抽象化するデバイスファイルを持っています」と来て絶望します。
<br>
<br>
順番的には3章でまず色んなコマンドを叩いてLinuxの操作に慣れてから、どういう仕組みになっているのかを学ぶ方が自然だと思います。
<br>
<br>

もし金銭的に余裕があるなら、[［試して理解］Linuxのしくみ　―実験と図解で学ぶOS、仮想マシン、コンテナの基礎知識【増補改訂版】](https://amzn.asia/d/fQmzFqG)みたいな、カラフルで分かりやすい本でイメージをつかむのがいいんじゃないかと思います。(パラっと立ち読みしただけなので本当に初心者が読んで分かるかは保証しませんw)
<br>
<br>
しかし、お金がない！どうしてもあずき本で対策しなければいけない！という方のために、あずき本1章1節を解説してみたいと思います。ゆくゆくは全部解説できたらいいなぁ。そして下剋上を・・・w
<br>
<br>
(ついでに言うと同じシリーズの白本も~~クソ~~分かりにくいですよね。  
明らかに必要のない説明をダラッダラ続けているページがあって腹が立ちます。)

# 想定読者
『1週間でLPICの基礎が学べる本』程度の知識を持っている人

# なぜハードウェアから入るのか
LinuxはOSなのに、なぜハードウェアについて学ぶのでしょうか。
<br>
<br>
それはOSが、ハードウェアという資源を制御するための仕組みだからです。
<br>
<br>
コンピュータに入っているアプリケーションは、ディスクからデータを読み出したり、CPUに処理をさせたり、キーボードから入力を受け付けたり画面に文字を表示させたりなど、常にハードディスクとの何らかのやり取りを行っています。
<br>
<br>
例えばChromeを立ち上げてYouTubeを流しながらWordで文書を作っているとします。もしそれぞれのアプリが好き勝手にハードディスクを使おうとすると、取り合いになってしまいます。
<br>
<br>
分かりやすくイメージするためにChromeとWordを挙げましたが、コンピュータは起動しているだけで「プロセス」と呼ばれるものがたくさん動いています。ざっくりプロセス=プログラムと考えてよいです。  
そのプロセスが全部ハードウェアにアクセスする訳です。何もしないと大混乱に陥ってしまいますね。
<br>
<br>
そこで交通整理をしてくれるのがOSという訳です。
<br>
<br>
しかしその交通整理役が、ハードウェアを正しく認識していなかったらどうでしょう。  
アプリからOSに対して、「Aというディスクに入っているデータを読み込んでね」と指示を出しても、OSがそれを認識していなければ、「そんなデータないよ～」となってしまう。
<br>
<br>

そこで、Linuxがちゃんとハードウェアを認識しているかを確認できる**ファイル**や**コマンド**があります。

# /procディレクトリ
まずは、「Linuxが認識しているハードウェア情報」を確認できるファイルについて。これは、**/proc**というディレクトリの中にあります。  
/proc/cpuinfoであればCPU情報、/proc/meminfoであればメモリ情報、といった具合です。
<br>
<br>
ちなみに/procディレクトリについて正確に説明すると、
<br>
<br> 
>プロセスやメモリーなどのLinuxシステム上のリソース関連情報を，あたかもファイルであるかのように配置した仮想的なファイル・システム  
>(出典：[日経クロステック　/proc](https://xtech.nikkei.com/it/article/Keyword/20071214/289515/))


<br>
です。
<br>
実際にファイルが存在している訳ではなく、ファイルのように見えるものがある、といった感じです。


<br>
<br>
/procディレクトリ内のファイルで試験に問われるのは以下のようなものです。<br>
余裕があれば、catコマンドで中身を見てみると良いでしょう。
<br>
<br>  

**/proc/cpuinfo**　CPU情報  
**/proc/meminfo**　メモリ情報  
**/proc/interrupts**　IRQ情報  
**/proc/ioports**　I/Oアドレス情報  
__/proc/bus/usb/*__　USBデバイス情報  
__/proc/bus/pci/*__　PCIデバイス(拡張カード)情報  
**/proc/dma**　使用中のDMAチャネルに関する情報  
**/proc/modules**　ロードされているカーネルモジュールに関する情報  
**/proc/scsi/scsi**　SCSIデバイスに関する情報
<br>
<br>

# ls○○○コマンド
次に、「Linuxが認識しているハードウェア情報」を確認できるコマンドです。<br>
lsホニャララというコマンドがいくつか用意されています。
<br>
<br>
 
**lscpu**　CPU  
**lsusb**　USBデバイス  
**lspci**　PCIデバイス(拡張カード)  
**lsmod**　ロードされているカーネルモジュール
<br>
<br>

# BIOS/UEFI
とまぁここまでハードウェアの様子を調べるためのファイルやコマンドを見た訳ですが、実はOSが起動する前、コンピュータの電源を入れたら一番に起動する、ハードウェアを制御するためのプログラムがあります。 
<br>
<br>
それが、BIOS(Basic Input Output System)です。
<br>
<br>
BIOSは一番最初に起動して、他のみんなをたたき起こす役割です。  
普段BIOSをいじることなんてほとんどないですが、
<br>
<br>

**・キーボードなど、デバイスを使うか使わないか**  
**・起動するOSをどこから読み込むか**
<br>
<br>
などを設定することができます。
<br>
<br>
＞起動するOSをどこから読み込むか  
というのは、最初はなかなかピンと来ないですよね。
<br>
<br>
私はこれの意味を急に分かった瞬間がありました。  
それは、古くなったMacからMacOSを削除し、Linuxを入れた時です。
<br>
<br>
LinuxをあらかじめインターネットからダウンロードしてUSBメモリに入れておき、Macに差した状態で電源を入れ、optionキーを長押しすると、どのディスクからOSを起動するか選ぶ画面が出てくるんです。
<br>
<br>
そこで、「ああなるほど、大量記憶装置にOSが入っていて、それを読み込んで起動するのね」と実感しました。  
普通にWindowsなりMacなりを使っているときはそんなの意識しないから、最初は分かりにくいんだと思います。
<br>
<br>
さてこのBIOSですが、最近はUEFI(Unified Extensive Firmware Extensive)というものに置き換わっているみたいです。進化バージョンですね。しかしUEFIもひっくるめてBIOSと言ったりもするみたいです。

# デバイスファイルと/devディレクトリ
話が少し戻ります。
<br>
<br>
最初の方で、/procディレクトリ以下のファイルを見たりlsホニャララコマンドを使ったりすることで、Linuxが認識しているハードウェアの情報を見ることができると説明しました。
<br>
<br>
では、Linuxはハードウェアのことをどうやって認識・操作しているのでしょうか。  
どうやって、と言われても漠然としていますねw
<br>
<br>
我々人間で考えてみると、ハードウェアというのは「ブツ」です。マウスやキーボードであれば、転がしたりタイピングしたりと、実際に触って操作しますね。
<br>
<br>
でもLinuxはそんなことはできません。
<br>
<br>
じゃぁどうするかというと、Linuxは全てのハードウェアをファイルとして認識しているんです。これを**デバイスファイル**と言い、デバイスファイルに対して読み書きをすることで、ハードウェアを操作します。
<br>
<br>
デバイスファイルはどこにあるかというと、**/dev**というディレクトリの中にあります。

# デバイスファイルの作られ方
/devディレクトリの中のデバイスファイルは、**udev**という仕組みによって作られます。  
ファイル作成係のudev君というのをイメージしてみると良いでしょう。
<br>
<br>
流れとしては、以下のようになります。
<br>
<br>

**デバイスが接続される  
↓  
Linuxカーネル(※)がそれを検知し、/sysディレクトリ以下にデバイス情報を作成する  
↓  
udev君がデバイス情報を参照し、/dev以下にデバイスファイルを作成する  
作成するとき、/etc/udev/rules.dディレクトリの中にある設定ファイルの設定を使う**
<br>
<br>

こうしてファイルが作られたら、**D-Bus**と呼ばれる仕組みを使ってデバイス情報がアプリケーションに送られ、アプリケーションはデバイスを利用することができるようになります。
<br>
<br>
D-Busはプロセス間通信機構とか出てきて何やら難しそうですが、Busとついているくらいですから、コンピュータの中にあるバス路線とでもイメージすれば分かりやすいかと思います。
<br>
<br>
<br>
ちなみに/etcディレクトリの中のホニャララ.dというのは設定関連でよく出てくるので、整理しながら覚えると良いです。業務でもよく使います。
<br>
<br>
※カーネルとは、Linuxの中核部分のソフトウェアのことです。

# デバイスドライバとカーネルモジュール
Linuxはファイルの読み書きを通してデバイス(ハードウェア)を操作することが分かりましたが、操作のためにはもう一つ必要なものがあります。それが、**デバイスドライバ**です。
<br>
<br>
よくPCに新しいプリンタなどを接続したら、インターネットから自動でドライバをダウンロードしてくれたりしますね。それです。デバイスを操作するためのプログラムです。
<br>
<br>

Linuxでは、デバイスドライバは必要に応じてカーネルに取り込めるようになっています。この「必要に応じてカーネルに取り込めるようになっているもの」の事を**カーネルモジュール**といいます。また、カーネルモジュールを取り込むことを「ロードする」と言います。
<br>
<br>
カーネルモジュールに関して覚えることは以下の2つです。
<br>
<br>
 
**lsmod**：ロードされているカーネルモジュールを確認するコマンド  
**modprobe**：カーネルモジュールを手動でロードする時のコマンド

# USBのデバイスドライバ
USBは、その機能によっていくつかの種類に分かれています。その種類のことをデバイスクラスといいます。  
それぞれのデバイスクラスに対し、**クラスドライバ**と呼ばれるデバイスドライバがあります。
<br>
<br>
主なデバイスクラスは以下の通りです。
<br>
<br>

**HID(Human Interface Device)**  
　マウスやキーボードなど
<br>
<br>

**マスストレージデバイス**  
　USBメモリ、HDDなど
<br>
<br>

**オーディオ**  
　マイク、スピーカー、サウンドなど
<br>
<br>

**プリンタ**  
　プリンタなど
<br>
<br>

**ワイヤレスコントローラー**  
　Wi-Fiアダプタ、Bluetoothアダプタなど

# おわりに
さて、できるだけはてなが浮かばないように1章1節を解説してみましたが、いかがだったでしょうか。  
あずき本と合わせて本記事を読んだら、ping-tに挑戦してみてください。  
スムーズに解けるようになっていたら嬉しいです。